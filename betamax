#!/bin/bash
# betamax - Terminal session recorder for TUI apps
# Inspired by charmbracelet/vhs, using tmux for headless operation

set -e

# Resolve script directory (follows symlinks for install via ln -s)
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
  DIR="$(cd "$(dirname "$SOURCE")" && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd "$(dirname "$SOURCE")" && pwd)"

# Check for record subcommand before sourcing modules
if [[ "${1:-}" == "record" ]]; then
  RECORD_SCRIPT="$SCRIPT_DIR/bin/betamax-record"
  if [[ ! -x "$RECORD_SCRIPT" ]]; then
    echo "Error: betamax-record not found or not executable" >&2
    echo "Expected location: $RECORD_SCRIPT" >&2
    exit 1
  fi
  shift
  exec "$RECORD_SCRIPT" "$@"
fi

# Source modules
source "$SCRIPT_DIR/lib/config.sh"
source "$SCRIPT_DIR/lib/args.sh"
source "$SCRIPT_DIR/lib/keys.sh"
source "$SCRIPT_DIR/lib/validate.sh"
source "$SCRIPT_DIR/lib/capture.sh"
source "$SCRIPT_DIR/lib/session.sh"
source "$SCRIPT_DIR/lib/runner.sh"

# Check for bc (required for timing calculations)
if ! command -v bc &>/dev/null; then
  echo "Error: bc is required for betamax timing calculations" >&2
  echo "Install with: brew install bc (macOS) or apt install bc (Linux)" >&2
  exit 1
fi

main() {
  # Parse command line arguments
  parse_args "$@"

  # Load keys from file if specified (with line tracking for validation)
  load_keys_file_with_lines

  # Process @source directives (import from other files)
  process_source_directives

  # Validate keys file before processing
  validate_keys_file

  # Exit early if only validating
  if [[ "$VALIDATE_ONLY" == true ]]; then
    echo "Validation passed"
    exit 0
  fi

  # Expand @repeat loops
  expand_loops

  # Process @set and @require directives
  process_directives

  # Compute runtime values
  compute_delay_sec
  compute_terminal_size

  # Start tmux session
  session_start

  # Wait for initial pattern if specified
  session_wait_for_pattern

  # Send keys
  run_keys

  # Capture final state if requested
  if [[ "$CAPTURE" == true ]]; then
    capture_final
  fi

  # Cleanup
  session_cleanup
}

main "$@"
